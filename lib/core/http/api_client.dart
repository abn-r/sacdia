import 'dart:async';
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:sacdia/core/auth_events/auth_event_service.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:get_it/get_it.dart';
import 'package:sacdia/features/auth/bloc/auth_bloc.dart';
import 'package:sacdia/features/auth/bloc/auth_event.dart';

/// Cliente API centralizado que maneja autom√°ticamente la renovaci√≥n de tokens
/// y proporciona gesti√≥n global de errores de autenticaci√≥n
class ApiClient {
  final Dio _dio;
  final SupabaseClient _supabase;
  final _tokenRefreshLock = Lock();
  bool _enableDetailedLogs;
  
  // Controla los reintentos m√°ximos de renovaci√≥n de token antes de considerar el error irrecuperable
  final int _maxRenewalRetries = 3;
  int _renewalAttempts = 0;
  
  // Utiliza GetIt para obtener una instancia de AuthEventService
  AuthEventService get _authEventService => GetIt.I<AuthEventService>();
  
  // Singleton para asegurar una sola instancia
  static final ApiClient _instance = ApiClient._internal();
  
  factory ApiClient({bool enableDetailedLogs = false}) {
    _instance._enableDetailedLogs = enableDetailedLogs;
    return _instance;
  }
  
  ApiClient._internal()
      : _dio = Dio(),
        _supabase = Supabase.instance.client,
        _enableDetailedLogs = false {
    _configureInterceptors();
  }
  
  Dio get dio => _dio;
  
  /// Configura todos los interceptores necesarios
  void _configureInterceptors() {
    // Interceptor para manejo de request/response/error
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: _onRequest,
        onResponse: _onResponse,
        onError: _onError,
      ),
    );
    
    // A√±adir interceptor de logs para facilitar depuraci√≥n si est√° habilitado
    if (_enableDetailedLogs) {
      _dio.interceptors.add(LogInterceptor(
        requestBody: true,
        responseBody: true,
        logPrint: (object) {
          debugPrint('üåê DIO: $object');
        }
      ));
    }
  }
  
  /// Interceptor para a√±adir el token de autenticaci√≥n a cada solicitud
  void _onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    if (_enableDetailedLogs) {
      debugPrint('üì§ API Request: ${options.method} ${options.path}');
    }
    
    // Verificar si el token est√° por expirar (menos de 5 minutos de vida)
    final session = _supabase.auth.currentSession;
    if (session != null) {
      final expiresAt = session.expiresAt;
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
      
      // Si el token expira en menos de 5 minutos, intentar renovarlo antes de la solicitud
      if (expiresAt != null && expiresAt - now < 300) { // 300 segundos = 5 minutos
        try {
          await _refreshToken();
          // Reiniciar contador de intentos si la renovaci√≥n fue exitosa
          _renewalAttempts = 0;
        } catch (e) {
          debugPrint('‚ö†Ô∏è Error preventivo al renovar token: $e');
          // Continuamos con el token actual aunque est√© por expirar
        }
      }
      
      // A√±adir el token (renovado o el actual) a la solicitud
      final token = _supabase.auth.currentSession?.accessToken;
      if (token != null) {
        options.headers['Authorization'] = 'Bearer $token';
        
        if (_enableDetailedLogs) {
          final truncatedToken = token.length > 15 
            ? '${token.substring(0, 10)}...${token.substring(token.length - 5)}'
            : token;
          debugPrint('üîë Token a√±adido a la solicitud: $truncatedToken');
        }
      }
    }
    
    // A√±adir Content-Type com√∫n
    options.headers['Content-Type'] = 'application/json';
    
    // Continuar con la solicitud
    handler.next(options);
  }
  
  /// Interceptor para manejar respuestas exitosas
  void _onResponse(Response response, ResponseInterceptorHandler handler) {
    if (_enableDetailedLogs) {
      debugPrint('üì• API Response [${response.statusCode}]: ${response.requestOptions.path}');
    }
    
    // Reiniciar contador de intentos despu√©s de una respuesta exitosa
    if (response.statusCode != null && response.statusCode! >= 200 && response.statusCode! < 300) {
      _renewalAttempts = 0;
    }
    
    handler.next(response);
  }
  
  /// Interceptor para manejar errores, especialmente 401 (token expirado) y 403 (no autorizado)
  Future<void> _onError(DioException error, ErrorInterceptorHandler handler) async {
    if (_enableDetailedLogs) {
      debugPrint('‚ùå API Error [${error.response?.statusCode}]: ${error.requestOptions.path}');
      debugPrint('Error detalle: ${error.message}');
    }
    
    // Manejar c√≥digo 401 - Token expirado / Sesi√≥n inv√°lida
    if (error.response?.statusCode == 401) {
      await _handle401Error(error, handler);
      return;
    } 
    // Manejar c√≥digo 403 - Acceso denegado / Permisos insuficientes
    else if (error.response?.statusCode == 403) {
      _handle403Error(error, handler);
      return;
    }
    // Si hay una respuesta con c√≥digo 400 (Bad Request), revisar si es un problema de formato 
    // o validaci√≥n, y formatear un mensaje m√°s amigable
    else if (error.response?.statusCode == 400 && error.response?.data is Map) {
      final data = error.response?.data as Map;
      if (data.containsKey('message')) {
        final errorMessage = data['message'];
        debugPrint('üõë Error de validaci√≥n API: $errorMessage');
      }
    }
    
    // Si llegamos aqu√≠, no pudimos manejar el error, continuamos con el flujo de error normal
    handler.next(error);
  }
  
  /// Maneja espec√≠ficamente los errores 401 (Unauthorized)
  Future<void> _handle401Error(DioException error, ErrorInterceptorHandler handler) async {
    try {
      final request = error.requestOptions;
      
      // Verificar si ya hemos intentado demasiadas veces
      if (_renewalAttempts >= _maxRenewalRetries) {
        // Intentar cerrar sesi√≥n autom√°ticamente si es un error persistente
        _forceLogout(
          'No fue posible renovar la sesi√≥n despu√©s de $_maxRenewalRetries intentos',
          error
        );
        
        // Reiniciar contador para futuros intentos
        _renewalAttempts = 0;
        
        // Continuar con el flujo de error
        handler.next(error);
        return;
      }
      
      // Incrementar contador de intentos
      _renewalAttempts++;
      
      // Usar lock para evitar m√∫ltiples renovaciones simult√°neas
      await _tokenRefreshLock.synchronized(() async {
        // Verificar si el token ya fue renovado por otra solicitud mientras esperaba
        if (_isTokenExpired()) {
          await _refreshToken();
        }
      });
      
      // Volver a intentar la solicitud original con el nuevo token
      final token = _supabase.auth.currentSession?.accessToken;
      if (token != null) {
        request.headers['Authorization'] = 'Bearer $token';
        
        if (_enableDetailedLogs) {
          debugPrint('üîÑ Reintentando solicitud con nuevo token');
        }
        
        // Crear una nueva solicitud con las mismas opciones
        final response = await _dio.fetch(request);
        handler.resolve(response);
        return;
      }
    } catch (e) {
      debugPrint('‚ùå Error al renovar token: $e');
      
      // Emitir evento de error de renovaci√≥n
      _authEventService.emitRenewalFailed(
        message: 'Error al renovar la sesi√≥n: ${e.toString()}',
        error: e
      );
      
      // Si los reintentos superan el m√°ximo, forzar logout
      if (_renewalAttempts >= _maxRenewalRetries) {
        _forceLogout(
          'No fue posible renovar la sesi√≥n despu√©s de $_maxRenewalRetries intentos',
          error
        );
      }
    }
    
    // Si llegamos aqu√≠, no pudimos resolver el error
    handler.next(error);
  }
  
  /// Maneja errores 403 (Forbidden)
  void _handle403Error(DioException error, ErrorInterceptorHandler handler) {
    // Extraer mensaje de error si est√° disponible
    String message = 'No tienes permiso para realizar esta acci√≥n';
    if (error.response?.data is Map && error.response!.data.containsKey('message')) {
      message = error.response!.data['message'];
    }
    
    // Emitir evento de error de autorizaci√≥n
    _authEventService.emitUnauthorized(
      message: message,
      error: error
    );
    
    // Continuar con el flujo de error
    handler.next(error);
  }
  
  /// Fuerza el cierre de sesi√≥n en caso de errores de autenticaci√≥n irrecuperables
  void _forceLogout(String message, dynamic error) {
    debugPrint('üîê Forzando cierre de sesi√≥n por error irrecuperable');
    
    // Emitir evento de sesi√≥n expirada
    _authEventService.emitSessionExpired(
      message: message
    );
    
    // Intentar cerrar sesi√≥n a trav√©s del AuthBloc
    try {
      final authBloc = GetIt.I<AuthBloc>();
      authBloc.add(SignOutRequested());
    } catch (e) {
      debugPrint('‚ö†Ô∏è No se pudo acceder al AuthBloc para cerrar sesi√≥n: $e');
    }
  }
  
  /// Comprueba si el token actual est√° expirado
  bool _isTokenExpired() {
    final session = _supabase.auth.currentSession;
    if (session == null) return true;
    
    final expiresAt = session.expiresAt;
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    
    return expiresAt == null || expiresAt <= now;
  }
  
  /// Renueva el token de autenticaci√≥n
  Future<void> _refreshToken() async {
    try {
      if (_enableDetailedLogs) {
        debugPrint('üîÑ Iniciando renovaci√≥n de token...');
      }
      
      // Supabase renueva autom√°ticamente el token con refreshSession
      final response = await _supabase.auth.refreshSession();
      final newSession = response.session;
      
      if (newSession != null) {
        final expiresAt = newSession.expiresAt;
        if (expiresAt != null) {
          final expiresAtDateTime = DateTime.fromMillisecondsSinceEpoch(expiresAt * 1000);
          debugPrint('‚úÖ Token renovado exitosamente. Nuevo vencimiento: $expiresAtDateTime');
        } else {
          debugPrint('‚úÖ Token renovado exitosamente, pero no tiene fecha de expiraci√≥n definida');
        }
      } else {
        debugPrint('‚ö†Ô∏è La renovaci√≥n del token no gener√≥ una nueva sesi√≥n');
        
        // Emitir evento de sesi√≥n expirada si no se pudo renovar
        _authEventService.emitSessionExpired();
        throw Exception('No se pudo renovar el token');
      }
    } catch (e) {
      debugPrint('‚ùå Error al renovar token: $e');
      
      // Emitir evento de error de renovaci√≥n
      _authEventService.emitRenewalFailed(
        message: 'No se pudo renovar la sesi√≥n autom√°ticamente',
        error: e
      );
      
      // Propagar el error para que pueda ser manejado por quien llama a este m√©todo
      rethrow;
    }
  }
  
  /// M√©todo p√∫blico para forzar la renovaci√≥n del token
  /// √ötil cuando se necesita asegurar un token fresco para operaciones cr√≠ticas
  Future<bool> forceTokenRenewal() async {
    try {
      await _refreshToken();
      return true;
    } catch (e) {
      debugPrint('‚ö†Ô∏è Error al forzar renovaci√≥n de token: $e');
      return false;
    }
  }
  
  /// M√©todo p√∫blico para obtener el token actual o renovarlo si est√° por expirar
  /// √ötil para operaciones manuales que requieren el token
  Future<String?> getValidToken() async {
    if (_isTokenExpired() || _isTokenExpiringSoon()) {
      try {
        await _refreshToken();
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error al obtener token v√°lido: $e');
        return null;
      }
    }
    return _supabase.auth.currentSession?.accessToken;
  }
  
  /// Verifica si el token expirar√° pronto (en menos de 5 minutos)
  bool _isTokenExpiringSoon() {
    final session = _supabase.auth.currentSession;
    if (session == null) return true;
    
    final expiresAt = session.expiresAt;
    if (expiresAt == null) return false;
    
    final now = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    return expiresAt - now < 300; // 300 segundos = 5 minutos
  }
}

/// Lock simple para sincronizaci√≥n
class Lock {
  Completer<void>? _completer;
  
  Future<T> synchronized<T>(Future<T> Function() action) async {
    // Esperar si hay un lock activo
    if (_completer != null) {
      await _completer!.future;
    }
    
    // Crear nuevo lock
    _completer = Completer<void>();
    
    try {
      // Ejecutar la acci√≥n
      final result = await action();
      // Liberar el lock
      _completer!.complete();
      return result;
    } catch (e) {
      // Liberar el lock incluso en caso de error
      _completer!.complete();
      rethrow;
    }
  }
} 